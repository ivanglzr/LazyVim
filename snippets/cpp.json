{
  "Competitive Programming": {
    "prefix": "cp",
    "body": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "",
      "#define ll long long int",
      "#define MOD 1000000007",
      "#define endl \"\\n\"",
      "#define pii pair<int, int>",
      "",
      "signed main() {",
      "  ios::sync_with_stdio(false);",
      "  cin.tie(nullptr);",
      "",
      "  $0",
      "",
      "  return 0;",
      "}"
    ],
    "description": "Basic Template for CP"
  },
  "Competitive Programming MultiTestcase": {
    "prefix": "cptc",
    "body": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "",
      "#define ll long long int",
      "#define MOD 1000000007",
      "#define endl \"\\n\"",
      "#define pii pair<int, int>",
      "",
      "void solve() {",
      "  $0",
      "}",
      "",
      "signed main() {",
      "  ios::sync_with_stdio(false);",
      "  cin.tie(nullptr);",
      "",
      "  int tc;",
      "  cin >> tc;",
      "",
      "  while (tc--)",
      "    solve();",
      "",
      "  return 0;",
      "}"
    ],
    "description": "MultiTestcase Template for CP"
  },
  "Log 2 Ceil": {
    "prefix": "log2ceil",
    "body": [
      "int log2ceil(int x) {",
      "  int cnt = 0;",
      "",
      "  while (x) {",
      "    x >>= 1;",
      "    cnt++;",
      "  }",
      "",
      "  return cnt;",
      "}"
    ],
    "description": "Log 2 Ceil function"
  },
  "Log 2 Floor": {
    "prefix": "log2floor",
    "body": [
      "int log2floor(int x) {",
      "  int cnt = 0;",
      "",
      "  while (x > 1) {",
      "    x >>= 1;",
      "    cnt++;",
      "  }",
      "",
      "  return cnt;",
      "}"
    ],
    "description": "Log 2 Ceil function"
  },
  "Segment Tree Template": {
  "prefix": "segt",
  "body": [
    "class SegmentTree {",
    "    int n;",
    "    vector<int> tree;",
    "",
    "private:",
    "    int combine(int a, int b) {",
    "        return a + b;",
    "    }",
    "",
    "    int identity() {",
    "        return 0;",
    "    }",
    "",
    "    void build(const vector<int>& a, int v, int tl, int tr) {",
    "        if (tl == tr) {",
    "            tree[v] = a[tl];",
    "        } else {",
    "            int tm = (tl + tr) / 2;",
    "            build(a, v * 2, tl, tm);",
    "            build(a, v * 2 + 1, tm + 1, tr);",
    "            tree[v] = combine(tree[v * 2], tree[v * 2 + 1]);",
    "        }",
    "    }",
    "",
    "public:",
    "    SegmentTree(const vector<int>& a) : n(a.size()), tree(4 * n, identity()) {",
    "        build(a, 1, 0, n - 1);",
    "    }",
    "",
    "    void update(int v, int tl, int tr, int pos, int val) {",
    "        if (tl == tr) {",
    "            tree[v] = val;",
    "        } else {",
    "            int tm = (tl + tr) / 2;",
    "            if (pos <= tm)",
    "                update(v * 2, tl, tm, pos, val);",
    "            else",
    "                update(v * 2 + 1, tm + 1, tr, pos, val);",
    "            tree[v] = combine(tree[v * 2], tree[v * 2 + 1]);",
    "        }",
    "    }",
    "",
    "    int query(int v, int tl, int tr, int l, int r) {",
    "        if (l > r) return identity();",
    "        if (l == tl && r == tr) return tree[v];",
    "        int tm = (tl + tr) / 2;",
    "        return combine(",
    "            query(v * 2, tl, tm, l, min(r, tm)),",
    "            query(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r)",
    "        );",
    "    }",
    "};"
  ],
  "description": "Segment tree with private identity() and combine(), build() called in constructor"
}

}
